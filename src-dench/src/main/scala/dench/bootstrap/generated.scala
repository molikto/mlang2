package dench.bootstrap
import utils._
import scala.collection.mutable
import treesitter.TreeSitterNative._
def unwrap_InstanceImplicit_Term(t: InstanceImplicitTerm_w): Plicit[Term] = Plicit(t.inner, Plicity.Instance)
def convert_and(t: Raw_and): Term = App(Proj(t.left, "and"), Seq(t.right))
def unwrap_Implicit_Name(t: ImplicitName_w): Plicit[Name] = Plicit(t.inner, Plicity.Im)
implicit def wrap_Explicit_Pattern(t: Pattern): Plicit[Pattern] = Plicit(t, Plicity.Ex)
def convert_not(t: Raw_not): Term = App(Proj(t.right, "not"), Seq())
def unwrap_Implicit_Term(t: ImplicitTerm_w): Plicit[Term] = Plicit(t.inner, Plicity.Im)
def convert_minus(t: Raw_minus): Term = App(Proj(t.left, "minus"), Seq(t.right))
def unwrap_InstanceImplicit_Pattern(t: InstanceImplicitPattern_w): Plicit[Pattern] = Plicit(t.inner, Plicity.Instance)
def convert_times(t: Raw_times): Term = App(Proj(t.left, "times"), Seq(t.right))
def convert_or(t: Raw_or): Term = App(Proj(t.left, "or"), Seq(t.right))
def unwrap_InstanceImplicit_Name(t: InstanceImplicitName_w): Plicit[Name] = Plicit(t.inner, Plicity.Instance)
implicit def wrap_Explicit_Term(t: Term): Plicit[Term] = Plicit(t, Plicity.Ex)
implicit def wrap_Explicit_Name(t: Name): Plicit[Name] = Plicit(t, Plicity.Ex)
def convert_plus(t: Raw_plus): Term = App(Proj(t.left, "plus"), Seq(t.right))
def unwrap_Implicit_Pattern(t: ImplicitPattern_w): Plicit[Pattern] = Plicit(t.inner, Plicity.Im)
def convert_divides(t: Raw_divides): Term = App(Proj(t.left, "divides"), Seq(t.right))
def convert_modulo(t: Raw_modulo): Term = App(Proj(t.left, "modulo"), Seq(t.right))
object Hole; def Hole_parser(node: TSTreeCursor): Hole.type = Hole
object BoxTypeDef; def BoxTypeDef_parser(node: TSTreeCursor): BoxTypeDef.type = BoxTypeDef
object BoxTypeClass; def BoxTypeClass_parser(node: TSTreeCursor): BoxTypeClass.type = BoxTypeClass
object BoxTypeExtension; def BoxTypeExtension_parser(node: TSTreeCursor): BoxTypeExtension.type = BoxTypeExtension
object BoxTypeInstance; def BoxTypeInstance_parser(node: TSTreeCursor): BoxTypeInstance.type = BoxTypeInstance
type BoxType = BoxTypeDef.type | BoxTypeExtension.type | BoxTypeInstance.type | BoxTypeClass.type
case class Raw_and(left: Term, right: Term)
case class Branch(params: Seq[PlicitPattern], clos: Term)
case class Def(keyword: BoxType, name: Name, intros: Seq[BoxOrField], typ: Term | Null, body: Term)
case class LiftRef(head: Ref, up: Int)
case class Lambda(branches: Seq[Branch])
case class Raw_times(left: Term, right: Term)
type Tele = Seq[BoxOrField]
case class Raw_plus(left: Term, right: Term)
case class Term_w(inner: Term)
case class ImportQuantified(head: Ref, tail: ImportExpr)
case class Raw_or(left: Term, right: Term)
case class Namespace(ref: Ref, boxes: Seq[Box])
case class MakePattern(fields: Seq[PlicitPattern])
case class At(left: Term, right: Term)
case class ImplicitPattern_w(inner: Pattern)
type Term = Enum | Ref | Eq | Lambda | App | At | Match | LiftRef | Proj | Pi | Record | Let | Hole.type | Int
case class ImportGrouped(items: Seq[ImportExpr])
case class Under(intros: Seq[BoxOrField], boxes: Seq[Box])
type PlicitPattern = Plicit[Pattern] | Plicit[Pattern] | Plicit[Pattern]
case class InstanceImplicitName_w(inner: Name)
case class InstanceImplicitPattern_w(inner: Pattern)
type Name = String 
type Box = Def | Under | Namespace
case class ImplicitName_w(inner: Name)
case class Enum(kases: Seq[Kase])
type ImportExpr = Ref | ImportQuantified
case class Record(fields: Seq[BoxOrField])
case class Eq(left: Term, right: Term)
case class Tele_w(inner: Seq[BoxOrField])
case class Raw_not(right: Term)
case class Raw_divides(left: Term, right: Term)
case class Pi(dom: TeleOrTerm, cod: Term)
case class ImplicitTerm_w(inner: Term)
case class RefSeq(names: Seq[String])
case class App(head: Term, args: Seq[PlicitTerm])
case class Match(terms: Seq[Term], lam: Lambda)
case class Kase(name: Name, fields: Seq[BoxOrField])
type PlicitName = Plicit[Name] | Plicit[Name] | Plicit[Name]
type Pattern = Name | MakePattern | ConstructPattern
case class Proj(head: Term, field: ProjRight)
case class Raw_modulo(left: Term, right: Term)
case class Raw_minus(left: Term, right: Term)
case class NamesTyp(names: Seq[PlicitName], typ: Term)
type TeleOrTerm = Seq[BoxOrField] | Seq[BoxOrField]
type BoxOrField = Box | NamesTyp
type ProjRight = Ref | LiftRef
case class SourceFile(imports: Seq[ImportExpr], boxes: Seq[Box])
type PlicitTerm = Plicit[Term] | Plicit[Term] | Plicit[Term]
type BoxOrTerm = Box | Term
case class ConstructPattern(kase: String, fields: Seq[PlicitPattern])
case class Let(items: Seq[BoxOrTerm])
case class InstanceImplicitTerm_w(inner: Term)
object Parsers {
def BoxType_parser(node: TSTreeCursor): BoxType = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 37 => BoxTypeDef_parser(node); case 39 => BoxTypeExtension_parser(node); case 40 => BoxTypeInstance_parser(node); case 38 => BoxTypeClass_parser(node); case a => handleUnknown(a, node) } }
def Raw_and_parser(node: TSTreeCursor): Raw_and = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var left: Term | Null = null; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 19 => left = Term_parser(node); case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Raw_and(left.nn.asInstanceOf[Term], right.nn.asInstanceOf[Term]) }
def Branch_parser(node: TSTreeCursor): Branch = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val params: mutable.ArrayBuffer[PlicitPattern] = new mutable.ArrayBuffer(); var clos: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 22 => params += PlicitPattern_parser(node); case 5 => clos = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Branch(params.toSeq, clos.nn.asInstanceOf[Term]) }
def Def_parser(node: TSTreeCursor): Def = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var keyword: BoxType | Null = null; var name: Name | Null = null; val intros: mutable.ArrayBuffer[BoxOrField] = new mutable.ArrayBuffer(); var typ: Term | Null = null; var body: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 17 => keyword = BoxType_parser(node); case 20 => name = Name_parser(node); case 13 => intros += BoxOrField_parser(node); case 27 => typ = Term_parser(node); case 2 => body = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Def(keyword.nn.asInstanceOf[BoxType], name.nn.asInstanceOf[Name], intros.toSeq, typ, body.nn.asInstanceOf[Term]) }
def LiftRef_parser(node: TSTreeCursor): LiftRef = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var head: Ref | Null = null; var up: Int | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 10 => head = map_Ref(RefSeq_parser(node)); case 28 => up = Nat_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); LiftRef(head.nn.asInstanceOf[Ref], up.nn.asInstanceOf[Int]) }
def Lambda_parser(node: TSTreeCursor): Lambda = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val branches: mutable.ArrayBuffer[Branch] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 4 => branches += Branch_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Lambda(branches.toSeq) }
def Raw_times_parser(node: TSTreeCursor): Raw_times = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var left: Term | Null = null; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 19 => left = Term_parser(node); case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Raw_times(left.nn.asInstanceOf[Term], right.nn.asInstanceOf[Term]) }
def Raw_plus_parser(node: TSTreeCursor): Raw_plus = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var left: Term | Null = null; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 19 => left = Term_parser(node); case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Raw_plus(left.nn.asInstanceOf[Term], right.nn.asInstanceOf[Term]) }
def Term_w_parser(node: TSTreeCursor): Term_w = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var inner: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 12 => inner = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Term_w(inner.nn.asInstanceOf[Term]) }
def ImportQuantified_parser(node: TSTreeCursor): ImportQuantified = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var head: Ref | Null = null; var tail: ImportExpr | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 10 => head = map_Ref(RefSeq_parser(node)); case 25 => tail = ImportExpr_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); ImportQuantified(head.nn.asInstanceOf[Ref], tail.nn.asInstanceOf[ImportExpr]) }
def Raw_or_parser(node: TSTreeCursor): Raw_or = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var left: Term | Null = null; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 19 => left = Term_parser(node); case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Raw_or(left.nn.asInstanceOf[Term], right.nn.asInstanceOf[Term]) }
def Namespace_parser(node: TSTreeCursor): Namespace = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var ref: Ref | Null = null; val boxes: mutable.ArrayBuffer[Box] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 23 => ref = map_Ref(RefSeq_parser(node)); case 3 => boxes += Box_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Namespace(ref.nn.asInstanceOf[Ref], boxes.toSeq) }
def MakePattern_parser(node: TSTreeCursor): MakePattern = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val fields: mutable.ArrayBuffer[PlicitPattern] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 9 => fields += PlicitPattern_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); MakePattern(fields.toSeq) }
def At_parser(node: TSTreeCursor): At = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var left: Term | Null = null; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 19 => left = Term_parser(node); case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); At(left.nn.asInstanceOf[Term], right.nn.asInstanceOf[Term]) }
def ImplicitPattern_w_parser(node: TSTreeCursor): ImplicitPattern_w = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var inner: Pattern | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 12 => inner = Pattern_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); ImplicitPattern_w(inner.nn.asInstanceOf[Pattern]) }
def Term_parser(node: TSTreeCursor): Term = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 82 => convert_or(Raw_or_parser(node)); case 83 => convert_and(Raw_and_parser(node)); case 84 => convert_plus(Raw_plus_parser(node)); case 85 => convert_minus(Raw_minus_parser(node)); case 86 => convert_times(Raw_times_parser(node)); case 87 => convert_divides(Raw_divides_parser(node)); case 88 => convert_modulo(Raw_modulo_parser(node)); case 89 => convert_not(Raw_not_parser(node)); case 73 => Enum_parser(node); case 48 => map_Ref(RefSeq_parser(node)); case 75 => Eq_parser(node); case 77 => Lambda_parser(node); case 69 => App_parser(node); case 79 => At_parser(node); case 80 => Match_parser(node); case 49 => LiftRef_parser(node); case 71 => Proj_parser(node); case 78 => Pi_parser(node); case 81 => Record_parser(node); case 74 => Let_parser(node); case 36 => Hole_parser(node); case 35 => Nat_parser(node); case a => handleUnknown(a, node) } }
def ImportGrouped_parser(node: TSTreeCursor): ImportGrouped = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val items: mutable.ArrayBuffer[ImportExpr] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 14 => items += ImportExpr_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); ImportGrouped(items.toSeq) }
def Under_parser(node: TSTreeCursor): Under = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val intros: mutable.ArrayBuffer[BoxOrField] = new mutable.ArrayBuffer(); val boxes: mutable.ArrayBuffer[Box] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 13 => intros += BoxOrField_parser(node); case 3 => boxes += Box_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Under(intros.toSeq, boxes.toSeq) }
def PlicitPattern_parser(node: TSTreeCursor): PlicitPattern = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 41 => NonEmptyName_parser(node); case 36 => mapped_Hole_Name(Hole_parser(node)); case 59 => MakePattern_parser(node); case 60 => ConstructPattern_parser(node); case 62 => unwrap_Implicit_Pattern(ImplicitPattern_w_parser(node)); case 63 => unwrap_InstanceImplicit_Pattern(InstanceImplicitPattern_w_parser(node)); case a => handleUnknown(a, node) } }
def InstanceImplicitName_w_parser(node: TSTreeCursor): InstanceImplicitName_w = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var inner: Name | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 12 => inner = Name_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); InstanceImplicitName_w(inner.nn.asInstanceOf[Name]) }
def InstanceImplicitPattern_w_parser(node: TSTreeCursor): InstanceImplicitPattern_w = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var inner: Pattern | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 12 => inner = Pattern_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); InstanceImplicitPattern_w(inner.nn.asInstanceOf[Pattern]) }
def Name_parser(node: TSTreeCursor): Name = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 41 => NonEmptyName_parser(node); case 36 => mapped_Hole_Name(Hole_parser(node)); case a => handleUnknown(a, node) } }
def Box_parser(node: TSTreeCursor): Box = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 54 => Def_parser(node); case 55 => Under_parser(node); case 56 => Namespace_parser(node); case a => handleUnknown(a, node) } }
def ImplicitName_w_parser(node: TSTreeCursor): ImplicitName_w = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var inner: Name | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 12 => inner = Name_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); ImplicitName_w(inner.nn.asInstanceOf[Name]) }
def Enum_parser(node: TSTreeCursor): Enum = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val kases: mutable.ArrayBuffer[Kase] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 16 => kases += Kase_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Enum(kases.toSeq) }
def ImportExpr_parser(node: TSTreeCursor): ImportExpr = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 48 => map_Ref(RefSeq_parser(node)); case 50 => ImportQuantified_parser(node); case a => handleUnknown(a, node) } }
def Record_parser(node: TSTreeCursor): Record = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val fields: mutable.ArrayBuffer[BoxOrField] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 9 => fields += BoxOrField_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Record(fields.toSeq) }
def Eq_parser(node: TSTreeCursor): Eq = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var left: Term | Null = null; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 19 => left = Term_parser(node); case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Eq(left.nn.asInstanceOf[Term], right.nn.asInstanceOf[Term]) }
def Tele_w_parser(node: TSTreeCursor): Tele_w = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val inner: mutable.ArrayBuffer[BoxOrField] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 12 => inner += BoxOrField_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Tele_w(inner.toSeq) }
def Raw_not_parser(node: TSTreeCursor): Raw_not = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Raw_not(right.nn.asInstanceOf[Term]) }
def Raw_divides_parser(node: TSTreeCursor): Raw_divides = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var left: Term | Null = null; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 19 => left = Term_parser(node); case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Raw_divides(left.nn.asInstanceOf[Term], right.nn.asInstanceOf[Term]) }
def Pi_parser(node: TSTreeCursor): Pi = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var dom: TeleOrTerm | Null = null; var cod: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 7 => dom = TeleOrTerm_parser(node); case 6 => cod = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Pi(dom.nn.asInstanceOf[TeleOrTerm], cod.nn.asInstanceOf[Term]) }
def ImplicitTerm_w_parser(node: TSTreeCursor): ImplicitTerm_w = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var inner: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 12 => inner = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); ImplicitTerm_w(inner.nn.asInstanceOf[Term]) }
def RefSeq_parser(node: TSTreeCursor): RefSeq = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val names: mutable.ArrayBuffer[String] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 21 => names += NonEmptyName_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); RefSeq(names.toSeq) }
def App_parser(node: TSTreeCursor): App = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var head: Term | Null = null; val args: mutable.ArrayBuffer[PlicitTerm] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 10 => head = Term_parser(node); case 1 => args += PlicitTerm_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); App(head.nn.asInstanceOf[Term], args.toSeq) }
def Match_parser(node: TSTreeCursor): Match = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val terms: mutable.ArrayBuffer[Term] = new mutable.ArrayBuffer(); var lam: Lambda | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 26 => terms += Term_parser(node); case 18 => lam = Lambda_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Match(terms.toSeq, lam.nn.asInstanceOf[Lambda]) }
def Kase_parser(node: TSTreeCursor): Kase = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var name: Name | Null = null; val fields: mutable.ArrayBuffer[BoxOrField] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 20 => name = Name_parser(node); case 9 => fields += BoxOrField_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Kase(name.nn.asInstanceOf[Name], fields.toSeq) }
def PlicitName_parser(node: TSTreeCursor): PlicitName = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 41 => NonEmptyName_parser(node); case 36 => mapped_Hole_Name(Hole_parser(node)); case 45 => unwrap_Implicit_Name(ImplicitName_w_parser(node)); case 46 => unwrap_InstanceImplicit_Name(InstanceImplicitName_w_parser(node)); case a => handleUnknown(a, node) } }
def Pattern_parser(node: TSTreeCursor): Pattern = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 41 => NonEmptyName_parser(node); case 36 => mapped_Hole_Name(Hole_parser(node)); case 59 => MakePattern_parser(node); case 60 => ConstructPattern_parser(node); case a => handleUnknown(a, node) } }
def Proj_parser(node: TSTreeCursor): Proj = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var head: Term | Null = null; var field: ProjRight | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 10 => head = Term_parser(node); case 8 => field = ProjRight_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Proj(head.nn.asInstanceOf[Term], field.nn.asInstanceOf[ProjRight]) }
def Raw_modulo_parser(node: TSTreeCursor): Raw_modulo = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var left: Term | Null = null; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 19 => left = Term_parser(node); case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Raw_modulo(left.nn.asInstanceOf[Term], right.nn.asInstanceOf[Term]) }
def Raw_minus_parser(node: TSTreeCursor): Raw_minus = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var left: Term | Null = null; var right: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 19 => left = Term_parser(node); case 24 => right = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Raw_minus(left.nn.asInstanceOf[Term], right.nn.asInstanceOf[Term]) }
def NamesTyp_parser(node: TSTreeCursor): NamesTyp = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val names: mutable.ArrayBuffer[PlicitName] = new mutable.ArrayBuffer(); var typ: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 21 => names += PlicitName_parser(node); case 27 => typ = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); NamesTyp(names.toSeq, typ.nn.asInstanceOf[Term]) }
def TeleOrTerm_parser(node: TSTreeCursor): TeleOrTerm = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 67 => unwrap_Term_Tele(Term_w_parser(node)); case 66 => unwrap_Tele(Tele_w_parser(node)); case a => handleUnknown(a, node) } }
def BoxOrField_parser(node: TSTreeCursor): BoxOrField = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 54 => Def_parser(node); case 55 => Under_parser(node); case 56 => Namespace_parser(node); case 52 => NamesTyp_parser(node); case a => handleUnknown(a, node) } }
def ProjRight_parser(node: TSTreeCursor): ProjRight = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 48 => map_Ref(RefSeq_parser(node)); case 49 => LiftRef_parser(node); case a => handleUnknown(a, node) } }
def SourceFile_parser(node: TSTreeCursor): SourceFile = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val imports: mutable.ArrayBuffer[ImportExpr] = new mutable.ArrayBuffer(); val boxes: mutable.ArrayBuffer[Box] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 11 => imports += ImportExpr_parser(node); case 3 => boxes += Box_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); SourceFile(imports.toSeq, boxes.toSeq) }
def PlicitTerm_parser(node: TSTreeCursor): PlicitTerm = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 82 => convert_or(Raw_or_parser(node)); case 83 => convert_and(Raw_and_parser(node)); case 84 => convert_plus(Raw_plus_parser(node)); case 85 => convert_minus(Raw_minus_parser(node)); case 86 => convert_times(Raw_times_parser(node)); case 87 => convert_divides(Raw_divides_parser(node)); case 88 => convert_modulo(Raw_modulo_parser(node)); case 89 => convert_not(Raw_not_parser(node)); case 73 => Enum_parser(node); case 48 => map_Ref(RefSeq_parser(node)); case 75 => Eq_parser(node); case 77 => Lambda_parser(node); case 69 => App_parser(node); case 79 => At_parser(node); case 80 => Match_parser(node); case 49 => LiftRef_parser(node); case 71 => Proj_parser(node); case 78 => Pi_parser(node); case 81 => Record_parser(node); case 74 => Let_parser(node); case 36 => Hole_parser(node); case 35 => Nat_parser(node); case 91 => unwrap_Implicit_Term(ImplicitTerm_w_parser(node)); case 92 => unwrap_InstanceImplicit_Term(InstanceImplicitTerm_w_parser(node)); case a => handleUnknown(a, node) } }
def BoxOrTerm_parser(node: TSTreeCursor): BoxOrTerm = { val sym = ts_node_symbol(ts_tree_cursor_current_node(node)); sym.toInt match { case 54 => Def_parser(node); case 55 => Under_parser(node); case 56 => Namespace_parser(node); case 82 => convert_or(Raw_or_parser(node)); case 83 => convert_and(Raw_and_parser(node)); case 84 => convert_plus(Raw_plus_parser(node)); case 85 => convert_minus(Raw_minus_parser(node)); case 86 => convert_times(Raw_times_parser(node)); case 87 => convert_divides(Raw_divides_parser(node)); case 88 => convert_modulo(Raw_modulo_parser(node)); case 89 => convert_not(Raw_not_parser(node)); case 73 => Enum_parser(node); case 48 => map_Ref(RefSeq_parser(node)); case 75 => Eq_parser(node); case 77 => Lambda_parser(node); case 69 => App_parser(node); case 79 => At_parser(node); case 80 => Match_parser(node); case 49 => LiftRef_parser(node); case 71 => Proj_parser(node); case 78 => Pi_parser(node); case 81 => Record_parser(node); case 74 => Let_parser(node); case 36 => Hole_parser(node); case 35 => Nat_parser(node); case a => handleUnknown(a, node) } }
def ConstructPattern_parser(node: TSTreeCursor): ConstructPattern = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var kase: String | Null = null; val fields: mutable.ArrayBuffer[PlicitPattern] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 15 => kase = NonEmptyName_parser(node); case 9 => fields += PlicitPattern_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); ConstructPattern(kase.nn.asInstanceOf[String], fields.toSeq) }
def Let_parser(node: TSTreeCursor): Let = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; val items: mutable.ArrayBuffer[BoxOrTerm] = new mutable.ArrayBuffer(); while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 14 => items += BoxOrTerm_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); Let(items.toSeq) }
def InstanceImplicitTerm_w_parser(node: TSTreeCursor): InstanceImplicitTerm_w = { val _cont0 = ts_tree_cursor_goto_first_named_child(node); var _cont = _cont0; var inner: Term | Null = null; while (_cont) { ts_tree_cursor_current_field_id(node).toInt match { case 12 => inner = Term_parser(node); case a => handleUnknown(a, node) }; _cont = ts_tree_cursor_goto_next_named_sibling(node) }; if (_cont0) ts_tree_cursor_goto_parent(node); InstanceImplicitTerm_w(inner.nn.asInstanceOf[Term]) }
}